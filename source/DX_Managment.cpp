[[nodiscard]]
u64 signal(ID3D12CommandQueue* command_queue, ID3D12Fence* fence, u64 value)
{
	u64 value_to_signal = ++value;
	THR(command_queue->Signal(fence, value_to_signal));
	return value_to_signal;
}

void wait_for_fence(ID3D12Fence* fence, u64 value_to_wait, HANDLE event)
{
	u64 completed_value = fence->GetCompletedValue();
	if (completed_value < value_to_wait)
	{
		THR(fence->SetEventOnCompletion(value_to_wait, event));
		WaitForSingleObject(event, INFINITE);
	}
}

[[nodiscard]]
u64 flush(ID3D12CommandQueue* command_queue, ID3D12Fence* fence, u64 value, HANDLE event)
{
	u64 value_to_signal = signal(command_queue, fence, value);
	wait_for_fence(fence, value_to_signal, event);
	return value_to_signal;
}

//TODO: Later probably abstracted device and abstracted context
template <typename T>
[[nodiscard]]
GPU_Resource upload_static_data(Array_View<T>data_cpu, ID3D12GraphicsCommandList* cmd_list, ID3D12Device2* device)
{
	GPU_Resource out{};
	ID3D12Resource* vb_staging = nullptr;
	const u32 buffer_size = data_cpu.size * sizeof(T);
	const D3D12_RESOURCE_DESC desc = CD3DX12_RESOURCE_DESC::Buffer(buffer_size);
			
	THR(device->CreateCommittedResource(get_const_ptr(CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD)),
			                                D3D12_HEAP_FLAG_NONE,
			                                &desc,
			                                D3D12_RESOURCE_STATE_GENERIC_READ,
			                                nullptr,
			                                IID_PPV_ARGS(&vb_staging)));
			
	void* ptr = nullptr;
	CD3DX12_RANGE range(0, 0);
	THR(vb_staging->Map(0, &range, &ptr));
	memcpy(ptr, data_cpu.data, buffer_size);
	vb_staging->Unmap(0, nullptr);
	
	out.desc = desc;
	out.state = D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER;
	THR(device->CreateCommittedResource(get_const_ptr(CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT)),
	                                    D3D12_HEAP_FLAG_NONE,
	                                    &desc,
	                                    D3D12_RESOURCE_STATE_COMMON,
	                                    nullptr,
	                                    IID_PPV_ARGS(&out.ptr)));
			
	cmd_list->CopyResource(out.ptr, vb_staging);
	cmd_list->ResourceBarrier(1, get_const_ptr(CD3DX12_RESOURCE_BARRIER::Transition
	                                                                        (out.ptr, 
	                                                                         D3D12_RESOURCE_STATE_COPY_DEST, 
	                                                                         out.state)));
	return out;
}

IDxcResult* compile_shader_default(LPCWSTR path, LPCWSTR name, LPCWSTR entry_point, LPCWSTR target )
{
	LPCWSTR args[] =
	   {
	   name,      // Optional shader source file name for error reporting and for PIX shader source view.
		 L"-E", entry_point,        // Entry point.
		 L"-T", target,      // Target.
		 L"-Zs",                // Enable debug information (slim format)
		 L"-D", L"MYDEFINE=1",  // A single define.
		 L"-Fo", name, // Optional. Stored in the pdb. 
		 L"-Fd", name, // Name of the pdb. This must either be supplied or the autogenerated file name must be used.
		 L"-Qstrip_reflect",    // Strip reflection into a separate blob. 
		 };
		 
		 //TODO: Consider reuse for same thread
		 IDxcCompiler3* dx_compiler = nullptr;
		 IDxcUtils* dx_utils = nullptr;
		 IDxcIncludeHandler* dx_incl_handler = nullptr;
		 IDxcResult* result = nullptr;
		 IDxcBlobUtf8* error = nullptr;
		 
		 // Defer without IDxcResult
		 auto d = defer([&] { RELEASE_SAFE(dx_compiler); RELEASE_SAFE(dx_utils); RELEASE_SAFE(dx_incl_handler);
		 RELEASE_SAFE(error); });
			 
		 THR(DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(&dx_utils)));
		 THR(DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(&dx_compiler)));
		 THR(dx_utils->CreateDefaultIncludeHandler(&dx_incl_handler));
			 
		 IDxcBlobEncoding* ptr_source = nullptr;
		 THR(dx_utils->LoadFile(path, nullptr, &ptr_source));
		 DxcBuffer source;
		 source.Ptr = ptr_source->GetBufferPointer();
		 source.Size = ptr_source->GetBufferSize();
		 source.Encoding = DXC_CP_ACP;
			
		 // Compile
		 dx_compiler->Compile(
			 &source,              // Source buffer.
			 args,                // Array of pointers to arguments.
			 _countof(args),      // Number of arguments.
			 dx_incl_handler,     // User-provided interface to handle #include directives (optional).
			 IID_PPV_ARGS(&result) // Compiler output status, buffer, and errors.
		 );
			 
		 // Print errors & warnings
		 result->GetOutput(DXC_OUT_ERRORS, IID_PPV_ARGS(&error), nullptr);
		 if (error != nullptr && error->GetStringLength() != 0)
		 { OutputDebugStringA(error->GetStringPointer()); }
			
		 // Check compilation status
		 HRESULT hr_status;
		 result->GetStatus(&hr_status);
		 if (FAILED(hr_status))
		 { wprintf(L"Compilation Failed\n"); }
			
		 return result;
}